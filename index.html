<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Sequential Web App</title>
    <link href="website/css/screen.css" rel="stylesheet" type="text/css">
    <link href="website/css/jquery.terminal-2.3.0.css" rel="stylesheet" type="text/css"></script>
    <link href="website/css/prism-coy.css" rel="stylesheet" type="text/css"></script>
    <script src="release/biwascheme-0.6.9-min.js" type="text/javascript"></script>
    <script src="website/js/jquery.mousewheel.min.js" type="text/javascript"></script>
    <script src="website/js/jquery.timers.min.js" type="text/javascript"></script>
    <script src="website/js/jquery.cookie.min.js" type="text/javascript"></script>
    <script src="website/js/jquery.terminal-2.3.0.js" type="text/javascript"></script>
    <script src="website/js/prism.js" type="text/javascript"></script>
    <script src="website/js/prism-scheme.js" type="text/javascript"></script>
    <script src="website/js/jquery.terminal.prism.js" type="text/javascript"></script>
    <script src="website/js/keyboard.js" type="text/javascript"></script>
    <script src="website/js/biwascheme_terminal.js" type="text/javascript"></script>
  </head>
  <body>

    <h2>Sequentially Programmed Web App</h2>

    <p>This project shows how a web application can be programmed sequentially.
      Basically this means its structure mirrors its execution flow.</p>

    <h2>Try It Now</h2>

    <div id="term"></div>
    
    <p>Sequential programming of a web application is radically different
      from the currently dominant style of web-application programming, but it should
      be remembered that the dominant style of programming for many (probably most)
      <em>offline</em> applications is sequential. The sequential style of programming is
      suitable for a wide range of applications and application programmers
      because it models a program after the stepwise logic used to complete a
      program's goal. The sequential style of programming is the easiest style to
      master, all things being equal, because it straightforwardly mirrors our
      thinking about what the program must do to fulfil its purpose.
      It is interesting to explore the possibility of writing web applications
      in a sequential style because the dominant, non-sequential styles
      make it difficult to follow execution flow through the program's code
      and thus complicate program development, testing, and refactoring.
      The discussion thread
      <a href="https://news.ycombinator.com/item?id=3510758">&quot;Node.js - A giant step backwards?&quot;</a>
      presents problems of a relatively new style of web-application
      programming, namely event-driven programming for the web server,
      that has become popular in the last few years.</p>
    <p>This README briefly explains how a traditional web application and a
      web application written in the newer event-driven style (<em>ala</em> Node.js) handle
      asynchronous events.
      Then it points out a working example of an application written for a
      continuation-based web server and online resources for learning important
      ideas about such applications. Finally it presents a continuation-based
      web application that runs entirely in the web browser--a single-page
      web application.</p>
    <h2>How Asynchronous Events Are Handled in Web Applications</h2>
    <p>Any program, simple or complex, that uses I/O (user I/O, disk reads,
      disk writes, or transfers of data between computers) must have a means of
      synchronizing itself with the completion of that I/O. For desktop applications,
      the operating system provides system calls, a scheduler, and library functions
      that allow the programmer to structure for his program to mirror
      the program's execution flow. For desktop applications, the waiting
      for completion of I/O can usually be neatly hidden within some function
      like read(), write(), getchar(), etc., but in most web applications written
      up to 2020, this mirroring is not possible, due to the stateless nature of
      the web. Not even a web application written to run entirely in the
      web browser (a single-page web application) can mirror program flow,
      due to the event-driven nature of JavaScript in the web browser.</p>
    <p>In 2020, web servers can be classified as event-driven (like Node.js) and
      non-event-driven (traditional web servers). An event-driven web server
      can react to many asynchronous events in real time, without holding up
      the main event loop.</p>
    <p>Web applications written for an event-driven web server and typical
      single-page web applications are structured using callbacks, deferreds,
      promises, or some form of continuation-passing style. Thus, their struction
      cannot mirror their flow. However, a web application written using <em>true</em>
      continuations <em>can</em> be structured to mirror its flow.</p>
    <h2>Traditional Web Applications vs. Web Applications Built upon Server-Side Web Continuations</h2>
    <p>Very often, web applications interact with the user by building request
      pages that pass program state information from web page to web page in
      cookies or hidden form fields, something like this Racket Scheme code:</p>
    <pre><code>	(define (sum query)
	(build-request-page &quot;First number:&quot; &quot;/one&quot; &quot;&quot;))
	
	(define (one query)
	(build-request-page &quot;Second number:&quot;
	&quot;/two&quot;
	(cdr (assq 'number query))))
	
	(define (two query)
	(let ([n (string-&gt;number (cdr (assq 'hidden query)))]
	[m (string-&gt;number (cdr (assq 'number query)))])
	`(html (body &quot;The sum is &quot; ,(number-&gt;string (+ m n))))))
	
	(hash-set! dispatch-table &quot;sum&quot; sum)
	(hash-set! dispatch-table &quot;one&quot; one)
	(hash-set! dispatch-table &quot;two&quot; two)
    </code></pre>
    <p>That is the typical, traditional programming style of writing a web application.
      Such a style is more complicated and unwieldy than a straightforward style
      employing server-side web continuations:</p>
    <pre><code>	(define (sum2 query)
	(define m (get-number &quot;First number:&quot;))
	(define n (get-number &quot;Second number:&quot;))
	`(html (body &quot;The sum is &quot; ,(number-&gt;string (+ m n)))))
    </code></pre>
    <p>Both the web server code and both versions of the application code are
      fully described in the section
      <a href="https://docs.racket-lang.org/more/#%28part._.Continuations%29">Continuations</a>
      of the page
      <a href="https://docs.racket-lang.org/more/#%28part._.Continuations%29">More: Systems Programming with Racket</a>.</p>
    <p>The reader is strongly encouraged to
      <a href="https://download.racket-lang.org/">download Racket</a>, load the
      <a href="https://docs.racket-lang.org/more/step9.txt">the finished Racket Scheme code</a>,
      and run the code‚Äîa five- to ten-minute exercise.
      The code can be loaded and run in Racket something like this (where 8080 is
      the port number to which the server responds and &quot;step9.txt&quot; is the full or
      relative pathname of the Racket Scheme code):</p>
    <pre><code>        $ ùê´ùêöùêúùê§ùêûùê≠
	Welcome to Racket v7.5.
	&gt; (enter! &quot;step9.txt&quot;)
	&quot;step9.txt&quot;&gt; (ùê¨ùêûùê´ùêØùêû ùüñùüéùüñùüé)
	#&lt;procedure:...webcon/step9.txt:17:2&gt;
	&quot;step9.txt&quot;&gt; 
    </code></pre>
    <p>(<code>$</code> and <code>&gt;</code> are prompts.)
      After starting the program, you can use the web application locally
      by typing <a href="http://localhost:8080/sum2">http://localhost:8080/sum2</a>
      into your web browser's address bar.
      The program asks for and waits for one number, then jumps to a second web page,
      where it asks for and waits for a second number, then jumps to a third web page,
      where it sums the two
      numbers. Along the way it stores continuations to remember its each halt
      after serving a page, even saving the first and second numbers.
      In case the user presses his browser's back button once or twice anywhere
      along the way, or retypes the URL of the second or first page, the program
      recalls its state when a number was typed into the respective page,
      and shows the number and again in its input form,
      just as the user originally typed it, and the user can change the number
      or accept it and continue the program as before.</p>
    <p>Section 5.2 of Christian Queinnec's paper
      <a href="https://pages.lip6.fr/Christian.Queinnec/PDF/www.pdf">'Inverting back the inversion of control or, Continuations versus page-centric programming'</a>
      describes a very similar web application but does not detail its implementation.</p>
    <h2>Client-Side Web Continuations</h2>
    <p>Server-side web continuations are interesting because of the simplification
      they provide for web applications. However, the memory that they consume
      can easily become a problem. Since each website user has his own
      web browser, it would be convenient to put the continuations in the browser,
      naturally scaling the application.
      This way, a web server serving the web application to 10,000 or 1,000,000
      users is not burdened by a heavy price of memory for continuations.
      This Git project demonstrates a way to create a web application using
      client-side continuations. It includes
      <a href="https://github.com/tomelam/BiwaScheme">BiwaScheme</a>, a nearly complete
      implementation of R5RS Scheme language in JavaScript, as a submodule.</p>
    <p>The test program, apart from supporting functions and macros,
      is just this:</p>
    <pre><code>	(reset
	(with-handlers '((click-handler &quot;#foo&quot;))
	(let ((input (get-input)))
	(displayln &quot;get-input returned&quot;)
	(displayln input))))
    </code></pre>
    <p>The macro <code>with-handlers</code> sets up any number of
      event handlers (<code>click</code>, <code>mousedown</code>, <code>mouseup</code>, <code>mouseover</code>,
      <code>timeout</code>, etc.)
      and removes them when execution exits its block.
      The function <code>get-input</code> sets up a continuation that returns
      execution to that point only after an event has occurred.</p>
    <p>Here are instructions for running the application:</p>
    <ol>
      <li>Clone the Git repository for the demo:</li>
    </ol>
    <pre><code>
git clone git@github.com:Mashweb/seq_webapp_biwascheme.git
    </code></pre>
    <ol start="2">
      <li>
	<p>In the embedded console near the top of this page, enter the test program:</p>
      </li>
      <li>
	<p>Type the following into the console.</p>
      </li>
    </ol>
    <pre><code>(define-macro (reset . prog)
  `(*reset (lambda () ,@prog)))

(define-macro (shift arg . prog)
  `(*shift (lambda (,arg) ,@prog)))

(define (*meta-continuation* v)
  (error "You forgot the top-level reset..."))

(define (*abort thunk)
  (let ((v (thunk)))
    (*meta-continuation* v)))

(define (*reset thunk)
  (let ((mc *meta-continuation*))
    (call-with-current-continuation
     (lambda (k)
       (set! *meta-continuation*
             (lambda (v)
               (set! *meta-continuation* mc)
               (k v)))
       (*abort thunk)))))

(define (*shift f)
  (call-with-current-continuation
   (lambda (k)
     (*abort (lambda ()
               (f (lambda (v)
                    (reset (k v)))))))))

;;;; utils

(define first car)
(define second cadr)
(define third caddr)

(define rest cdr)

(define (displayln text)
  (display text)
  (newline))

(define-macro (push! item place)
  `(set! ,place (cons ,item ,place)))

(define-macro (delete! item place)
  `(set! ,place (remove ,item ,place)))

(define (remove item list)
  (cond
   ((equal? item (car list))
    (cdr list))
   (else
    (cons (car list)
          (remove item (cdr list))))))

(define-macro (js-call% func . args)
  `(js-call (js-eval ,func) ,@args))

(define-macro (js-lambda args . body)
  `(js-closure (lambda ,args ,@body)))

(define-macro (wind-protect setup teardown . body)
  (let ((result-g (gensym "RESULT")))
    `(begin
       ,setup
       (let ((,result-g (begin ,@body)))
         ,teardown
         ,result-g))))

;;;; with-handlers

(define (input-listener-cont . args)
  (display "Handler called with no listener continuation up"))

(define-macro (with-handlers handlers . body)
  `(wind-protect
       (setup-handlers ',handlers)
       (remove-handlers ',handlers)
     ,@body))

(define (setup-handlers handlers)
  (process-handlers handlers second))

(define (remove-handlers handlers)
  (process-handlers handlers third))

(define (process-handlers handlers part)
  (map (lambda (handler)
         (let ((handler-func (part (assq (first handler) handlers-impl)))
               (handler-args (rest handler)))
           (apply handler-func handler-args)))
       handlers))

(define (make-event-handler sym)
  (lambda (this event)
    (input-listener-cont (list sym this event))))

(define-macro (define-event-handler handler-name event-sym)
  (let* ((event-name (symbol->string event-sym))
         (handlers-container (string->symbol (string-append event-name "-handlers%")))
         (add-handler `(lambda (selector)
                         (let ((handler (add-handler! selector ,event-name
                                                      (make-event-handler ',event-sym))))
                           (hashtable-set! ,handlers-container selector handler))))
         (remove-handler `(lambda (selector)
                            (let ((handler (hashtable-ref ,handlers-container selector #f)))
                              (remove-handler! selector ,event-name handler)
                              (hashtable-delete! ,handlers-container selector)))))
    `(begin
       (define ,handlers-container (make-eqv-hashtable))
       (push! (list ',handler-name
                    ,add-handler
                    ,remove-handler)
              handlers-impl))))

(define ajax-handlers-container (make-eqv-hashtable))
(define timeout-handlers-container (make-eqv-hashtable))

(define handlers-impl
  (list
   (list 'timeout-handler
         (lambda (key timeout)
           (hashtable-set! timeout-handlers-container key
                           (js-call% "setTimeout"
                                    (js-lambda ()
                                      (input-listener-cont (list 'timeout key)))
                                    timeout)))
         (lambda (key timeout)
           (js-call% "clearTimeout"
                     (hashtable-ref timeout-handlers-container key #f))
           (hashtable-delete! timeout-handlers-container key)))
   (list 'ajax-handler
         (lambda (key url data)
           (hashtable-set! ajax-handlers-container key #t)
           (let ((ajax-func (js-eval "$.ajax")))
             (ajax-func (js-obj "url" url
                                "data" (apply js-obj data)
                                "success" (js-lambda (data)
                                            (if (hashtable-ref ajax-handlers-container key #f)
                                                (input-listener-cont (list key 'success data))))
                                "error" (js-lambda (jqxhr status error)
                                          (if (hashtable-ref ajax-handlers-container key #f)
                                              (input-listener-cont (list key 'error status error))))))))
         (lambda (key url data)
           (hashtable-delete! ajax-handlers-container key)))))

(define-event-handler click-handler click)
(define-event-handler keydown-handler keydown)
(define-event-handler keyup-handler keyup)

;;;; get-input

(define-macro (get-input)
  `(shift c (set! input-listener-cont c)))

;;;; Test

(define (test)
  (display
   (with-handlers ((click-handler "#div1")
                   (click-handler "#div2")
                   (keydown-handler "#db1")
                   (keydown-handler "#db2")
                   (ajax-handler example-data "/" ())
                   (timeout-handler test-timeout 5000))
    (let ((input (get-input)))
      (display "get-input returned")
      input)))
  (display
   (with-handlers ((click-handler "#div1")
                   (click-handler "#div2")
                   (keydown-handler "#db1")
                   (keydown-handler "#db2")
                   (ajax-handler example-data "/" ())
                   (timeout-handler test-timeout 5000))
    (let ((input (get-input)))
      (display "get-input returned")
      input)))
  (display
   (with-handlers ((click-handler "#div1")
                   (click-handler "#div2")
                   (keydown-handler "#db1")
                   (keydown-handler "#db2")
                   (ajax-handler example-data "/" ())
                   (timeout-handler test-timeout 5000))
    (let ((input (get-input)))
      (display "get-input returned")
      input))))
    </code></pre>
    <ol start="4">
      <li>Click on the word 'Input' near the top of the page. (This word is
	enclosed in an HTML <code>&lt;div&gt;</code> element having the ID <code>foo</code>,
	so it is targeted by the <code>click</code> handler's
	event.) The following will be printed in the <code>Log</code>:</li>
    </ol>
    <pre><code>	get-input returned
	(click #obj&lt;HTMLDivElement&gt;)
    </code></pre>
    <ol start="5">
      <li>Click on the word 'Input' again. Confirm that nothing is added to the <code>Log</code>.
	This is because the click handler is automatically removed after the
	program falls through the <code>with-handlers</code> block.</li>
    </ol>
    </div>

    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-2023947-5', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
